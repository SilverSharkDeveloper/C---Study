C언어

프로그램 : 소스코드로 잘 짜여진 틀
소스코드 : 컴퓨터와 개발자가 소통한 명령어

	프로그램
	OS(운영체제) : 프로그램을 실행하면 소스코드가 os로 전달이 된후 OS가 문법을 이해하고 문법에 맞는 적절한 전기신호를 하드웨어에 흘려준다.
	하드웨어

프로그래밍 언어
	프로그램을 제작할 수 있는 언어
	운영체제와 개발자가 소통을 할 수 있는 문법을 가진 언어이다.

C언어 소개
	1972년 부터 사용된 오래된 언어이다.
	메모리 용량이 작았기 때문에 메모리를 효율적으로 관리하기 위한 목적이 강하다.
	하드웨어를 직접 제어할 수 있기 때문에 강력한 언어이며 개발자를 믿는 언어이다.
	모바일 개발도 가능하긴 하지만 애플리케이션이 잘못되면 핸드폰도 망가져 선호하지 않는다.

프로젝트 만들기
	솔루션 
		프로젝트
			소스파일(.c)
				소스코드

void main(){} -> .exe를 만들어주는 함수

컴파일 단축기 - ctrl f5

변수 : 저장공간
	
RAM(메모리)
=================
OS Kernel Space : 드라이버가 할당됨
=================
Stack	: 지역변수, 매개변수
=================
Heap	: 동적 메모리
=================
BSS	: 초기화 되지 않은 전역변수
=================
DATA영역 : 전역변수,정적변수(static)
=================
Text	: 상수, 코드
=================

변수 선언시 주의사항
	같은 이름의 변수를 선언할 수 없다.
	초기화를 해준다. ->쓰레기값(garbage value)값이 남아있으므로 
	선언부에 한꺼번에 되도록 선언한다.
	
변수명 주의사항
	문자부터 시작한다.(숫자가 먼저 나오면 값으로 취급)
	특수문자를 쓸 수 없다(단_는 가능)
	공백을 사용할 수 없다. (공백은 대기해라 라는 명령어이므로) ->언더바로 해결
	되도록 소문자만 사용한다. ->새로운 단어의 시작을 대문자로 시작하기 때문(카멜 표기법)
	명사로 사용한다.
	한글은 되도록 사용하지 않는다.

변수 선언시 RAM
	int x = 0;
	x라는 이름의 저장공간이 RAM에 할당되고 고유한 값인 주소값이 부여된다.

주소
	저장공간이 RAM에 할당되면, 유일무이한 값인 주소값이 부여되고 변수명으로 검색하는 것 보다 상대적으로 빠르다.

출력함수
printf("");

서식문자(format)
	반드시 따옴표 안에서 작성한다.
	
	
	%d : decimal : 10진수 정수
	%o : ocatal(8진수 정수)
	%x : haxadecimal(16진수 정수)
	%f : float : 실수
	%lf : double : 실수
	%c : 문자
	%s : 문자열
	
puts()문자열 출력후 자동 줄바꿈

변수를 사용하는 이유
	1.반복되는 값을 쉽게 관리하기 위해서
	2.값에 의미를 부여하기 위해서
	
형변환
	자료형을 변환하는 기법
	-자동형변환
		정수와 정수를 연산 : 정수
		정수와 실수를 연산 : 실수
	-강제형변환
		(자료형)값

입력함수
	입력상태:커서가 깜빡이고 있는 상태
	입력받기 전에 출력을 사용하여 어떤 정보를 입력해야 할 지 알려줘야 한다.
	
scanf_s("입력받을 값의 서식문자",&입력받은 값을 저장할 변수명, 변수의 크기)

헤더 파일
	항상 C언어 파일 상단에서 사용하기 때문에 "헤더 파일"이라고 한다.
	헤더파일을 추가하는 방법은 2가지가 있다.
	1.<헤더파일.h> : 라이브러리에 이미 있는 헤더파일
	2."헤더파일.h" : 사용자가 직접 만든 헤더파일

연산자
	기능이 있는 특수문자

결합성
	하나의 수식에 동일한 연산자가 있다면, 해당 연산자의 방향에 맞게 결합되어 연산되는 성질

비트 연산
~not 논리부정 : ~a, 1을 0으로 0을 1로
		~a = -a-1

쉬프트 연산자 :
	a<<b : a를 왼쪽으로 b만큼 비트를 민다.(1당 두배)
	a>>b : a를 오른쪽으로 b만큼 비트를 민다.(1당 반감)

조건식
	참 또는 거짓, 둘 중 하나가 나오는 식
	거짓 : 0
	참 : 0이외의 모든 수 , 1로 약속한다.
*c++에서 참과 거짓은 모두 정수인 값으롯 int 타입 변수에 담을 수 있다*
*boolean타입이 따로 없고 인트 값 0 과 1 로 참과 거짓을 나눈다.*

연산자
	관계연산자 : 
	==
	!=
	>,<
	>=,<=
	
	논리연산자 : 두개 이상의 조건식을 연결할 때
	&&
	||
	
	단항연산자
	! : 참거짓 변경

삼항 연산자( ? : )
	조건식 ? 참 : 거짓
	삼항 연산자에서 참, 거짓 자리에 값을 작성하면, 삼항연산자 통채로는 참 또는 거짓에 작성한 값으로 봐야한다.
	*참 거짓 자리에 값이아닌 문장이라면 값으로 보지 않는다.*

제어문:컴파일의 진행방향을 제어한다.
	<1>.조건문
	1.if문 - 조건식이 하나가아니라 여러개를 연결해야 하는 경우 또는 대소비교 
		1.상위 조건식의 참과 거짓의 여부와 상관없이 모든 조건식을 검사해야하는경우
		if(조건식){
			실행할문장;
		}
		if(조건식){
			실행할문장;
		}
		if(조건식){
			실행할문장;
		}


		2.조건식중 참인값이 하나라도 나오면 밑에 식은 실행시키지 않는다.
		if(조건식){
			실행할문장;
		}
		위의 조건식이 참이 아니면 순차적으로 검사 조건식에 위에 조건식이 아닌경우를 이미 포함하므로 이는 포함시키지 않는다.
		elseif(조건식){
			실행할문장;
		}
		else(조건식이 필요없다 위에 모든 조건이 아닐경우 실행되는 문){
			실행할문장;
		}

	2.switch문
		switch(변수명){
		case 변수값1 :
			실행할문장;
			break;
		case 변수값2 :
			실행할문장;
			break;
		case 변수값3 :
			실행할문장;
			break;
		case 변수값4 :
			실행할문장;
			break;
		....
		default(모든 케이스가 아닌경우) :	
			실행할문장;
			break;    -->없어도 되지만 다른 언어에서 오류가 날수 있다.
		}
증감연산자(++,--)
	전위형 후위형 중 상관없을경우는 후위형을 대부분 사용한다.


	<2>반복문
	1.for문:몇번 반복할지 알 때
		for(초기식 ; 조건식 ; 증감식){
			실행할문장
		}
		for문에서의 알고리즘 유의점
		//012012012 --같은수 반복은 나머지연산을 이용한다.
	        //0~2라는 범위 ->범위가 보이면 나머지연산 n%a -> 0~a-1까지의 범위가 된다.
		//항상 i =0 에서 규칙을 찾아 분기처리로한다.
	
기타 연산자	
	break : 컴파일러가 만나는 즉시 해당 중괄호 영역 탈출
		***if문 안에서 break를 사용하면 if문 탈출이 아닌 if문을 감싸고 있는 영역탈출.
		***switch문 안에서 break를 사용하면 switch문만 탈출 할 수 있다.
	
	continue : 컴파일러가 만나는 즉시 다음 반복으로 넘어감
		***continue는 밑에 있는 문장을 실행하지 않을때에 사용한다.


	2.while문 : 몇번 반복할지 모를때 사용
	while(조건식){
		반복할 문장;
	}
	
	3.do while문 : 무조건 한번은 실행할 조건으로 사용한다.
	do{
	실행할 문장;
	}while(조건식);

**포인터**
 	저장공간을 가리키고 있는 주소값.
pintf("%p(주소값을 가져오는 서식문자)",&(주소값을 가져올 변수);

변수 : 값을 담는 저장공간
포인터 변수 : 주소값을 담는 저장공간

주소연산자 : &(앰퍼센트) : 변수앞에 사용해 그 변수를 담은 저장공간의 주소값을 가져온다.
참조연산자 : *(아스타리스크) : 반드시 주소값 앞에서 사용된다. -> 그 주소값 안에 들은 값을 참조한다.
 
포인터연산자 : *(아스타리스크) : 자료형 뒤에서 사용된다. 
ex)int* p(변수명) = &(주소값을 가져올 변수이름)

포인터 연산
	주소값에 연산을 하여 다음 칸 혹은 이전 칸에 접근하기 위해 사용한다.
	***연산시 해당 주소의 자료형 크기 만큼 연산된다.*** (시작주소에서 다음주소까지는 자료형 크기 만큼 지나야 하기 때문에)

배열 : 저장공간의 나열
	
	**배열을 선언하면 칸을 만들고 값을 넣은 후 그 첫번째 값이 들은 주소값을 참조변수로 저장한다. 이때 다른 값에 접근하고 싶다면
		포인터 연산을통해 다음 주소값에 접근하는데 +1을 해주면 된다. 
		ex) int arData = {1,2,3,4,5};
			*(arData +1) ==2    ->먼저 저장한 주소값에 +1을 하여 다음칸에 주소값을 가져오고 *를통해 그 안에 있는 값을 읽어온다.
						    하지만 부호도 너무많고 복잡해 치환을 한다.
			arData[1] ==2     -> 이렇게 사용한다. 첫번째 칸의 값이 arData[0]인 이유도 첫번째 주소값을 가져와 참조변수에 저장하므로 
					 		연산을통해 더해줄 필요가 없기 때문이다.

**주의 ** scanf_s로 받아온 값을 배열에 저장하고 싶을때 arData자체가 주소값이기 때문에 &를 붙여주지 않는다. 마찬가지로 arData[0]은 그 주소값 안에있는
	값을 가져오기 때문에 &를 붙여주어야 한다. 이렇게 되면 주소값에 있는 값을 가져와 다시 주소값을 붙여주는 이중 연산이다.
	그러므로 &와 []모두 쓰지 않고 arData, arData+1, arData+2 이런식으로 주소값을 가져온다.
	
배열 사용 목적
	1. 변수를 여러 개 선언하게 되면 이름도 많아지기 때문에 관리하기 힘드므로 여러 칸 배열을 한번 선언해 관리하기가 편하다.
	2. 규칙성이 없는 값에 규칙성을 부여할 수 있다. 
		->각배열의 인덱스 번호가 순차적으로 증가하므로!
	

배열의 선언
	자료형 배열명[길이] = {값1,값2,...}
	자료형 배열명[길이] = {초기값,}  -> 무슨 수를 넣을지 모를 때 빈칸은 전부 디폴트값이 들어간다,반드시 값하나와 콤마 하나가 필요하다.

*초기값
	정수 : 0
	실수 : 0.0
	문자 : '(스페이스바)'

배열의 크기	
	sizeof(배열명) : 전체 바이트 크기가 나옴
배열의 길이(칸수)
	sizeof(배열명) / sizeof(자료형)

배열의 사용
1.배열명[index] = 값;	//저장공간으로 사용
2.배열명[index] + 값 ;	//값으로 사용

index가 0부터 시작하는이유
	배열명은 시작주소를 가지고 있기 때문이다.
	따라서 값에 접근할 때에는 주소값 앞에 *(참조연산자)를 붙여주어야한다.
	포인터 연산을 통해 배열명 + 정수로 각 주소에 접근하고
	참조연산자를 맨 앞에 붙여 값에 접근한다.
	첫번째 칸의 값에 접근할 때에는 *(배열명 +0)이기 때문에 
	인덱스 번호는 0부터 시작이다.

문자열 : 문자 배열
	char 배열명[길이] = {'문자1','문자2'...};
		->문자 갯수가 5라면 6칸을 만들어 마지막칸은 자동적으로 널문자가 들어가 그 끝지점을 알려주어야 한다.
			ex)apple -> char fruit[6] = {'a','p','p','l','e'};  (6칸이지만 마지막칸은 자동적으로 널문자가 들어감)

		너무 귀찮으니 이렇게 문자열로 바로 인식한다 ->	char 배열명[길이] = "문자열";

		char name [] = "문자열";	
		->칸을 알려주지 않으면 자동으로 배열의 길이를 측정해줌



널문자(\0) :  문자열의 끝을 알려주는 문자.
		널문자가 있어야지만 정상적으로 문자열을 읽어올 수 있다.
		문자 배열의 시작주소를 알려주면 널문자 전까지 일게 된다.
		**널 문자는 자동으로 문자열 맨 끝에 위치하기 때문에 반드시 문자열의 길이 보다 한칸더 할당해 주어야 한다.**

문자열 입력
	사용자가 할당한 배열의 크기를 넘어가는 문자열을 입력하게 되면 할당하지 않은 주소에 엉뚱한 값이 들어가버린다.
	따라서 안전하지 않게 된다.
	이를 막기 위해서는 입력함수에 할당한 배열의 크기를 전다하므로써 미리 크기를 넘어가는 문자열을 막아주도록 해준다.

scanf_s("서식문자",&저장공간, sizeof(저장공간));
	저장할 공간의 크기를 미리 알려줌으로써 배열보다 긴 값을 넣을 때 차단해준다.
	->만약 차단되면 아무값도 넣지 않는다.
*********************************************************************************************
문자열을 선언하는 두가지 방식
1.문자 배열을 이용한 선언
	char str1[] = "My String";
		-배열의 길이는 자동으로 계산된다.
		-배열을 기반으로하는 "변수 형태의 문자열 선언"이다.
			->변수 형태의 문자열 선언이기 때문에 각각 칸에 접근도 가능하고 값을 바꾸는것도 가능하다.
			->하지만 주소값 변경이 불가능하다. -> 상수 형태의 포인터 ->배열변수명이 가리키는 주소값을 변경할 수 없는 상수이다.

2.char형 포인터 변수
	-char* str1 = "My String";
		-메모리 공간에 문자열이 저장된다.
		-문자열의 첫 번째 주소값이 반환되고 그 주소값을 포인터 변수 str1에 저장한다.
		-상수 형태의 문자열 선언이다.
			->각 값에 접근은 가능하지면 변경은 불가능하다.
			->하지만 주소값 변경이 가능하다 -> 포인터 변수에 새로운 문자열 저장이 가능하다.->새로운 문자열을 만들고 그 주소값을 저장한다.
						


문자열의 단점 : 문자 배열은 문자열 저장까진 가능하지만 변경은 할 수 없다(포인터 상수이기떄문에)
 ->포인터 변수를 이용해 문자열을 저장하면 그 문자열 통으로 바꿀 수 있다.

배열의 이름은 그 값을 변경할 수 없는 상수라는 점을 제외하면 포인터와 같습니다.
따라서 배열의 이름은 포인터 상수(constant pointer)입니다.

const char* 포인터명 : 그 주소에 접근후 값을 수정할 수 없다.
const char* const 포인터명 : 주소값 자체를 수정할 수 없다.


====================================================
string.h ->스트링 헤더파일

1.strcpy_s(배열명,sizeof(배열명),"새로운 값");
->기존 배열의 값을 전달한 새로운 값으로 변경

2.strcmp(값1,값2); ->같으면 0, 다르면1 **일반비교랑 반대로 같으면 0,다르면 1의값이나온다 주의!!**
 ->문자열 비교

3.strlen(배열명); 
->전체 문자의 길이 -> 널문자를 제외한 실제 값의 길이
**널문자 앞까지만 카운팅을 한다**

배열은 포인터 상수이다. 처음시작 주소값을 다른 주소값으로 바꿀땐 오류가 발생한다.
->바꾸기위해서 입력받아 변경은 가능하다.
->바꾸기위해선 strcpy_s로 바꿔준다.

2차원 배열
	배열안에 배열

2차원 배열 선언
	자료형 배열명[행][열]={{1,2,..}{3,4..}..};
	자료형 배열명[행][열]={초기값,};

2차원 배열 사용
	*(배열명 + 3) +3 //주소값
	*(*(배열명 + 3)) + 3 //값 ->4행 0열의 값 +3
      	*(*(배열명)+2)  //0행 3열의 값

이중 for문 (Nested For)
	for(초기식;조건식;증감식){
		실행할 문장;                          1
		for(초기식;조건식;증감식){
				실행할문장;         2
		}
	실행할문장;                                    3
	}

첫번째 반복문은 안에 작성된 문장이 모두 끝나야 다음 반복으로 넘어가기 때문에
두번째 반복문은 첫번째 반복문 반복횟수만큼 초기식으로 돌아간다.

1번문장: 첫번째 반복문의 매 반복마다 처음으로 실행되는 문장
2번문장: 첫번째 반복문의 매 반복마다 두번째 반복문이 처음부터 다시 시작된다. ->(첫번째 반복문 * 두번째 반복문)횟수만큼 실행되는 문장
3번문장: 두번째 반복문이 끝날 때 마다 실행되는 문장


함수
	이름뒤에 소괄호()가 있으면 함수이다.
	단,키워드 뒤에 소괄호가 있으면 함수가 아니다.
	예) if(), for(),while, switch,

함수의 정의
	    f         (x)     = 2x+1 
	함수명(매개변수) = 리턴값

함수의 선언
	리턴타입(리턴값의 자료형) 함수명(자료형 매개변수1,....)
	{
		실행할 문장;
		return 리턴값;
	}

리턴타입 : 리턴값의 타입을 작성한다. 리턴 값이 없다면 비워놓지 않고 voide라는 타입을 작성한다 ->리턴이 없다는 의미

함수명 : 동사로 작성한다. (연필(매개변수)을 쓴다.(함수명))
매개변수 : 생략이 가능하지만 외부에서 값을 전달받기 위해서는 반드시 자료형과 순서에 맞게 선언해주어야 한다.
실행할문장 : 생략 가능 main함수에서 작성해왔던 소스코드들.
리턴값 : 생략가능

함수의 선언과 사용 구분
	{}가 있으면 선언, {}가 없으면 사용

함수 선언시 주의사항
	함수 안에 다른 함수를 선언할 수 없으며, 함수 사용은 반드시 함수 안에서 사용해야 한다.
	**함수를 사용할 때 선언부 소스코드 밑에 있으면 인식이 안되기 대문에, 반드시 함수 선언은 사용하는 부분 위에 선언되어야 한다.**
		->사용하려는 함수가 소스코드 밑에있다면 그보다 위에 선언부는 작성되어있어야한다.
			->리턴타입 똑같은 이름의 함수명 (매개변수의 타입만 적어도 인식가능) ;
				->실행할 문장과 리턴값 같은 나머지는 아래에 선언되어있으면 사용할 수 있다.
		
함수 선언 시 순서
1.함수명을 생각한다.
2.매개변수를 생각한다.
3.실행할 문장을 작성한다.
4.리턴 값을 작성한다.
5.리턴 타입을 결정한다. 

함수의 사용
	함수명(값,...);	
	
	리턴값이 있다면 통채로를 리턴값으로 본다.
	리턴값이 없다면 값으로 봐서는 안된다.
	

리턴값으로 배열을 담고싶은 경우 :
** 리턴타입에 자료형 뒤에 포인터연산자(*)를 써주고 리턴 값으로 배열의 주소값을 써준 후 함수를 호출하는 쪽에서 담을 변수 역시
	똑같은 자료형에 포인터연산자를 쓴 변수명으로 받아주어야한다. (배열로 받으면 컴파일오류)

함수를 사용하는 이유
	1.재사용성 -단 특정성을 부여해서는 안된다. ->특정성을 부여하면 재사용할 수 없기때문에 ->기능만 저장
	2.소스코드 간결화
	
리턴을 해야 할 때
	사용하는 부분에 작업의 결과를 전달해야 할 때
	함수 안에서 모든 작업이 끝나지 않을 때

리턴을 안할 때
	사용하는 부분에 작업의 결과를 전달할 필요가 없을때
	함수 안에서 모든 작업이 끝날 때

﻿
<전역변수,정적변수,헤더파일>

같은 프로젝트 안에 있는 다른 소스파일(.c)에 있는 전역 변수는

-> extern 키워드를 사용해 사용가능

같은 프로젝트 안에 있는 다른 소스파일(.c)에 있는 정적 변수는 사용 불가

->자기 소스파일에서만 사용할 변수는 정적변수(static)으로 선언

같은 프로젝트 안에 있는 헤더파일(.h)를 include 하면

->헤더파일 안에 있는 전역변수, 정적변수 모두 사용 가능

﻿

extern : 다른C언어 파일(.c)에 있는 전역변수를 가져오고 싶을때 쓰는 키워드
		
저장 기억 부류(Storage Class)

				stack		heap		data영역
				지역변수	동적메모리	전역변수	
				매개변수			정적변수
초기화				직접		직접		자동
생명주기(메모리해제)	}(닫는중괄호) free()	         프로그램 종료시


ctrl + \ + e ->오류목록 열기
빌드 실패시 오류목록이 안뜨는게있고 뜨는게있음 

=========================================================================
포인터 : 주소값
-포인터 변수 : 주소를 담는 변수
-포인터 상수 : 주소를 담는 상수 (배열)

& : 주소 연산자 (번지 연산자) ->저장공간의 주소값을 가져옴
자료형* : 포인터 연산자
*주소값 : 참조 연산자 -> 그주소안에있는 값을 읽어라

f9 = 중단점 설정 ->한줄씩 실행후 중단점 설정된 줄에서 멈춤
f5 = 컴파일만 ->디버깅
f11 다음코드 실행 (한줄씩)

f5(디버그) -> 창 -> 메모리 클릭 : 실시간 메모리 할당을 볼 수 있음
->f11로 중단점부터 한줄씩 코드실행해 실시간 메모리에 할당된 값의 변화를 볼 수 있음

<포인터를 사용하는 이유>
	1.다른 영역에 있는 변수의 값을 수정하기 위해서 ->굳이 리턴하지말고 매개변수로 주소값을 받아 직접 주소에 접근해 값을 변경
	->지역변수같은 경우 그 영역이 끝나면 사라지기 때문에 주소로 접근해 값을 변경하면 다른 영역에 있는 변수의 값을 수정할 수 있다.
	->﻿함수는 한개의 값만 리턴할 수 있으므로 포인터를 사용해 다른영역의 값을 변경할 수 있다.
**값을 받아와 접근하는것은 call by value
    주소값을 받아와 접근 call by adress
﻿
          2 .동적 메모리 (heap) 할당 ->몇개의 데이터가 들어올지 모를 때 사용

-필요한 헤더파일 :stdlib.h

-동적 할당(dynamic allocation)
	-동적 배열 할당 
	자료형* 포인터명 = (자료형*)malloc(sizeof(자료형)*길이); ->초기화를 직접 해주어야함

         -동적 배열 초기화(clear allocation)
	자료형*포인터명 = (자료형*)calloc(길이, sizeof(자료형));  ->자동 초기화 ->초기값이 들어가는것이 아닌 byte값이 다 0으로 설정

-동적 배열 크기 변경(resize allocation)
	(이미 만들어진 동적배열)포인터명 = (자료형*)realloc(포인터명,sizeof(자료형)*길이);
		->이미 만들어진 동적 배열의 포인터에 새로운 크기에 동적 배열을 만들어 그 주소값을 저장한다.
	
-동적 메모리 해제 ->힙메모리에 저장된 메모리는 무조건 직접 해제해주어야한다!!!!! (heap메모리는 자동 해제가 없고 무조건 직접 해주어야한다)
			free(포인터명);
			메모리를 해제하지 않으면 사라지지 않고 남아있기 때문에 꼭 반드시 free()함수로 메모리해제를 해주어야 한다.



**malloc(크기) ->동적메모리에 사용자가 입력한 크기만큼 동적인 배열 할당해주는 함수
			->리턴타입이 void*형이다 -> 그러므로 사용자가 입력한 자료형으로 강제 형변환을 해주어야한다!! 
			->반드시 앞에쓴 자료형과 뒤에 형변환해준 자료형이 같아야 한다.
viod* ->모든타입의 포인터를 담을 수 있는 포인터
	
구조체(사용자 정의 타입)
	추상적인 개념
	공통요소(멤버 변수)로 구조화 시켜놓은것

목적
	반복되는 공통 요소를 쉽게 관리하기 위해서

구조체 선언
	1.struct 구조체 이름{
		자료형 멤버변수명
		(함수는 불가능)
	.....
	}; **세미콜론 필수!**
       
	 구조체 사용 
	struct 구조체이름 변수명;
	변수명.멤버변수명 = 값;
	
	초기화-> struct 구조체이름 변수명 = {값,...}; ->순서와 자료형에 맞게 작성해주어야한다. 만약 값을 넣지 않으면 자료형에 맞게 초기값이 들어간다.

	->매번 struct쓰는게 불편하다
<typedef>
자료형에 별명을 지정
typedef int 정수;
정수 i = 10;


        2.typedef struct 구조체 이름{
		자료형 멤버변수명	
	...
	}구조체 별명;
	
	-> struct를 쓰지않고 구조체 별명으로 바로 선언과 사용이 가능하다.

선언 시 주의사항
	함수 밖에서 선언해야 한다.
	구조체 선언 시 멤버 변수에 초기값을 넣을 수 없다.


구조체 변수명 ->구조체를가짐 즉 구조체형태의 값을 가짐


int a;  ->인트형 저장공간 하나 생성 그 변수명 a
int a = 0; ->인트형 저장공간 하나 생성 그 변수명 a 그 저장공간에 0 저장 
&a -> 변수 a 의 저장공간의 주소값
int * b ; -> 인트형 저장공간을 가진 주소값을 저장할 포인터변수 b 선언  ->자료형은 주소값을 찾아가보니 있는 값의 자료형
b= &a -> 변수a의 주소값을 포인터변수 b에 저장 -> 포인터 변수 b안에는 인트 변수 a의 주소값을 담고 있다.

typedef struct AA{
	int a;
	char b;
}A;                        -> A = struct AA

main(){
A a;          ->A구조체형 저장공간 하나 생성 그 구조체 변수명a
A a = {0,'a'};  ->A구조체형 저장공간 하나 생성 그 구조체 변수명 a 그 저장공간에 있는 멤버 변수에 값을 저장
&a -> 구조체 변수 a 의 주소값
A* b ; -> A구조체 형 저장공간을 가진 주소값을 저장할 포인터변수b 선언 -> 주소값을 찾아가보니 있는 값의 자료형은 A구조체 이다.
b= &a; ->A구조체 형을 가진 변수 a의 주소값을 포인터 변수 b 에 저장 -> 포인터 변수 b안에는 구조체A의 변수 a의 주소값을 담고있다.

**구조체는 배열과 달리 변수명을 선언할때 주소값을 저장하는것이 아니다.**

주소연산시 그 구조체의 크기만큼 지난 다음 주소가 나온다
b+1 -> 주소값은 8더해진다.

구조체의 크기 (size) 매우복잡
기본적으로 컴퓨터가 데이터를 가져올때 4바이트 단위로 데이터를 읽어온다
이때 데이터 정렬에따라 만약 6바이트짜리 데이터가있을때0000dddddd00
정렬된 데이터는 8바이트를 읽어오고 만약 데이터가 000dddddd000이런식으로 정렬ㅇ되어있으면 12바이트를 읽어와야한다.
그래서 구조체 데이터 정렬을 위해 명시적으로 의미없는 데이터를 추가해 크기를 맞출 수 있는데
그 전에 컴파일러가 구조체를 컴파일하면서 암묵적인 데이터 추가를 수행한다.

실제로 구조체를 만들때 이런식으로 만들어진다.
1.가장큰 바이트를 가진 데이터 타입을 기준으로 정렬한다.
2.순서대로 넣는중 데이터가 크기를 넘어가면 나머지는 패딩후 다음칸에 데이터를 저장한다.
3.마지막 데이터를 넣고 나머지 부분도 패딩한다
-> 최종 크기는 가장큰 데이터타입의 크기의 배수이다.
->순서대로 데이터를 저장하기때문에 자료형 선언의 순서에 따라서도 크기가 달라질 수 있다.

**주소값을 담는 포인터의 크기는 8byte이다.**



배열의 변수명 = 주소값
어떤 자료형이든 포인터의 크기는 8byte ->주소값의 크기
 

	
	

﻿

	
